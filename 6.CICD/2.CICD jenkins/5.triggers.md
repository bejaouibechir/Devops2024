# Les Triggers 

### A) Repo Git minimal (GitHub ou GitLab)

- Branche `main` (et `dev` si tu fais les scÃ©narios MR).
- Un `Jenkinsfile` Ã  la racine (je te donne 7 variantes ci-dessous, tu en utilises une Ã  la fois).
- Un petit script de build pour voir un â€œvraiâ€ rÃ©sultat (ex: test â€œfacticeâ€).

CrÃ©er le fichier **scripts/test.sh** :

```bash
#!/usr/bin/env bash
set -euo pipefail

# Petit test "factice" mais visible dans la console Jenkins
echo "OK - tests passed at $(date -Is)"
```

### B) Jenkins : job â€œPipelineâ€

- Type : **Pipeline**
- â€œPipeline script from SCMâ€
- SCM : **Git**
- URL : ton repo
- Credentials : token/SSH selon ton cas
- Branch specifier : `*/main` (ou `*/dev` selon scÃ©nario)
- Script Path : `Jenkinsfile`

---

# 1) Trigger `pollSCM` + intÃ©gration Git (GitHub/GitLab)

**IdÃ©e (1â€“2 lignes)** : Jenkins â€œsondeâ€ le repo toutes les X minutes; si un commit arrive, il build.

**Input pour tester (dans GitHub/GitLab)**

- Modifie `README.md` et push sur `main`.

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  triggers {
    // Jenkins interroge le SCM toutes les 2 minutes
    pollSCM('H/2 * * * *')
  }

  stages {
    stage('Checkout') {
      steps {
        // RÃ©cupÃ¨re le code depuis le SCM configurÃ© dans le job
        checkout scm
      }
    }

    stage('Test') {
      steps {
        // ExÃ©cute un test simple et visible
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

---

# 2) Trigger â€œpÃ©riodiqueâ€ (`cron`) + intÃ©gration Git

**IdÃ©e** : le pipeline tourne Ã  heure fixe mÃªme sans commit (ex : build nocturne).

**Input pour tester**

- Attendre lâ€™heure/intervalle, ou clique â€œBuild Nowâ€ une premiÃ¨re fois pour vÃ©rifier le pipeline.

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  triggers {
    // Ex: toutes les 5 minutes (pour tester rapidement)
    cron('H/5 * * * *')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Nightly-like checks') {
      steps {
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

---

# 3) Trigger â€œupstreamâ€ (Job B dÃ©clenchÃ© par Job A)

**IdÃ©e** : un pipeline â€œparentâ€ dÃ©clenche un pipeline â€œenfantâ€ aprÃ¨s succÃ¨s.

**Input pour tester**

- Lance le job A manuellement (Build Now). Il dÃ©clenche le job B.

### Job A : `app-build`

CrÃ©er le fichier **Jenkinsfile** (dans repo A ou mÃªme repo si tu fais 2 jobs sur 1 repo) :

```groovy
pipeline {
  agent any

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Build') {
      steps {
        echo "Build OK"
      }
    }

    stage('Trigger downstream') {
      steps {
        // DÃ©clenche le job B (nom exact dans Jenkins)
        build job: 'app-deploy', wait: false
      }
    }
  }
}
```

### Job B : `app-deploy`

**Important** : dans la config du job B, coche :

- **Build Triggers** â†’ **Build after other projects are built** â†’ `app-build`

CrÃ©er le fichier **Jenkinsfile** (job B) :

```groovy
pipeline {
  agent any

  stages {
    stage('Deploy') {
      steps {
        echo "Deploy triggered by upstream job"
      }
    }
  }
}
```

---

# 4) Trigger `githubPush()` (webhook GitHub)

**IdÃ©e** : un push GitHub appelle Jenkins via webhook (instantanÃ©, pas de polling).

**Inputs Ã  configurer**

1. Jenkins â†’ job â†’ **Build Triggers** : coche **GitHub hook trigger for GITScm polling**
  
2. GitHub â†’ repo â†’ **Settings â†’ Webhooks â†’ Add webhook**
  
  - Payload URL : `http://JENKINS_URL/github-webhook/`
  - Content type : `application/json`
  - Events : â€œJust the push eventâ€
3. Test : push un commit sur `main`.
  

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  triggers {
    // Active le hook GitHub (le vrai dÃ©clenchement vient du webhook)
    githubPush()
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Build/Test') {
      steps {
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

---

# 5) Trigger GitLab Push (webhook GitLab)

**IdÃ©e** : GitLab envoie un webhook Ã  Jenkins au push.

**Inputs Ã  configurer (avec plugin GitLab recommandÃ©)**

1. Installer plugin **GitLab** dans Jenkins
  
2. Jenkins â†’ job â†’ **Build Triggers** : coche **Build when a change is pushed to GitLab**
  
3. Jenkins fournit une URL de webhook (souvent du type) :
  
  - `http://JENKINS_URL/project/JOB_NAME`
  - - token si configurÃ©
4. GitLab â†’ repo â†’ **Settings â†’ Webhooks**
  
  - URL : celle fournie par Jenkins
  - Trigger : **Push events**
5. Test : push commit sur `main`.
  

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Test') {
      steps {
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

---

# 6) â€œMain changeâ€ : build seulement si `main` a changÃ© (skip sinon)

**IdÃ©e** : mÃªme si le job est dÃ©clenchÃ©, on ne fait les Ã©tapes lourdes que quand `main` (ou certains fichiers) changent.

**Input pour tester**

- Push commit sur `main` qui modifie `README.md` (doit builder)
- Push commit qui modifie un autre fichier (selon rÃ¨gle) (doit skip les Ã©tapes protÃ©gÃ©es)

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Run only when important files change on main') {
      when {
        allOf {
          branch 'main'
          changeset "README.md"
        }
      }
      steps {
        echo "README.md changed on main -> running tests"
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }

    stage('Otherwise') {
      when { not { allOf { branch 'main'; changeset "README.md" } } }
      steps {
        echo "No targeted change on main -> skipping heavy steps"
      }
    }
  }
}
```

---

# 7) Merge Request `dev -> main` (GitLab) / Pull Request (GitHub)

### 7A) GitLab Merge Request `dev -> main`

**IdÃ©e** : Jenkins build quand une MR est crÃ©Ã©e/mise Ã  jour vers `main`.

**Inputs Ã  configurer**

1. GitLab : crÃ©er branche `dev`
2. GitLab â†’ crÃ©er **Merge Request** de `dev` vers `main`
3. Jenkins job : trigger GitLab (plugin) configurÃ© pour MR events (selon plugin : â€œMerge Request eventsâ€ / â€œPipeline eventsâ€)
4. Test : push un commit sur `dev` â†’ MR se met Ã  jour â†’ Jenkins build.

CrÃ©er le fichier **Jenkinsfile** :

```groovy
pipeline {
  agent any

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('MR checks (dev -> main)') {
      steps {
        // On fait simple : on exÃ©cute des checks systÃ©matiques sur l'Ã©vÃ©nement MR
        echo "Running MR checks"
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

### 7B) GitHub Pull Request (Ã©quivalent)

**IdÃ©e** : Jenkins build sur PR via webhook (souvent via Multibranch Pipeline + GitHub Branch Source).

**Inputs Ã  configurer**

1. Jenkins : crÃ©er **Multibranch Pipeline**
2. Ajouter source : GitHub (GitHub Branch Source)
3. Activer dÃ©couverte des PR
4. Test : crÃ©er PR `dev -> main` et push un commit sur `dev`.

CrÃ©er le fichier **Jenkinsfile** (mÃªme que ci-dessus) :

```groovy
pipeline {
  agent any

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('PR checks') {
      steps {
        echo "Running PR checks"
        sh 'chmod +x scripts/test.sh'
        sh './scripts/test.sh'
      }
    }
  }
}
```

Oui.
**Avec cette condition exacte**, le stage sâ€™exÃ©cute **uniquement si les deux conditions sont vraies en mÃªme temps** :

- le build concerne la branche **`main`**
- **`README.md` a Ã©tÃ© modifiÃ©** dans le(s) commit(s) qui ont dÃ©clenchÃ© le build

ğŸ‘‰ **Cas concrets :**

| Branche | Fichier modifiÃ© | Stage exÃ©cutÃ© |
| --- | --- | --- |
| main | README.md | âœ… Oui |
| main | src/app.py | âŒ Non |
| dev | README.md | âŒ Non |
| dev | autre fichier | âŒ Non |

---

### DÃ©tail important Ã  connaÃ®tre

- `changeset "README.md"` **ne dÃ©clenche pas le build**
  ğŸ‘‰ il **filtre seulement lâ€™exÃ©cution du stage**
  
- Le dÃ©clenchement vient toujours du trigger :
  
  - `pollSCM`
  - webhook GitHub / GitLab
  - cron
  - upstream
- Si le build dÃ©marre mais que `README.md` nâ€™a pas changÃ© sur `main`, **le stage est simplement ignorÃ©**.
  

---

### Variante utile (si tu veux plusieurs fichiers)

```groovy
changeset "**/*.md"
```

â†’ le stage sâ€™exÃ©cute si **nâ€™importe quel fichier Markdown** change sur `main`.

---

### Variante frÃ©quente (exclure README.md)

```groovy
when {
  branch 'main'
  not {
    changeset "README.md"
  }
}
```

Si tu veux, je peux te montrer **comment bloquer totalement le pipeline** (et pas seulement le stage) quand `README.md` est le seul fichier modifiÃ© â€” câ€™est un cas trÃ¨s courant en CI.

Oui.
**Avec cette condition**, le stage sâ€™exÃ©cute **pour nâ€™importe quel changement**, **tant que la branche est `main`**.

```groovy
stage('Run only when important files change on main') {
  when {
    branch 'main'
  }
}
```

### Ce que Ã§a signifie concrÃ¨tement

- âœ”ï¸ `main` + nâ€™importe quel fichier modifiÃ© â†’ **stage exÃ©cutÃ©**
- âŒ autre branche (`dev`, `feature/*`) â†’ **stage ignorÃ©**
- âœ”ï¸ push, merge, MR/PR fusionnÃ©e vers `main` â†’ **stage exÃ©cutÃ©**

### Points importants Ã  garder en tÃªte

- Le **trigger** (webhook, pollSCM, cronâ€¦) dÃ©marre toujours le build
- Le `when` dÃ©cide **si le stage sâ€™exÃ©cute ou non**
- Un merge `dev â†’ main` compte comme un changement sur `main` â†’ le stage passe

### Nom du stage (optionnel mais plus juste)

Si tu veux Ãªtre prÃ©cis :

```groovy
stage('Run on any change on main') {
  when {
    branch 'main'
  }
}
```
