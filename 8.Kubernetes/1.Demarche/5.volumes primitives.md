# Le volume type emptyDir partag√© entre conteneurs du m√™me pod

Voici une d√©marche d√©taill√©e pour tester le **volume emptyDir** avec le manifeste fourni.

Voici un exemple de **manifest Kubernetes** pour un **Pod avec deux conteneurs partageant un volume `emptyDir`**.  

### ** Sc√©nario**  
- Un **conteneur "writer"** √©crit un fichier dans `/data/shared`.  
- Un **conteneur "reader"** lit ce fichier et affiche son contenu.  
- Ils partagent un **volume `emptyDir`**, ce qui signifie que les donn√©es existent tant que le Pod est en cours d'ex√©cution.  

---

### ** Manifest YAML**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: writer
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - echo "Hello from writer!" > /data/shared/message.txt;
        sleep 3600;
    volumeMounts:
    - name: shared-storage
      mountPath: /data/shared

  - name: reader
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - sleep 5;
        cat /data/shared/message.txt;
        sleep 3600;
    volumeMounts:
    - name: shared-storage
      mountPath: /data/shared

  volumes:
  - name: shared-storage
    emptyDir: {}
```

### ** D√©ploiement & Test**
1Ô∏è **Appliquer le manifest**  
```bash
kubectl apply -f multi-container-pod.yaml
```

2Ô∏è **V√©rifier que le Pod est en cours d'ex√©cution**  
```bash
kubectl get pods
```

3Ô∏è **Voir les logs du lecteur**  
```bash
kubectl logs multi-container-pod -c reader
```

 Tu devrais voir `Hello from writer!` s'afficher.


## Une deuxi√®me utilisation de emptydir

Le fragment indique une utilisation particuli√®re de `emptyDir` o√π le volume est stock√© en **RAM** gr√¢ce √† l‚Äôattribut `medium: Memory`. Voici une d√©marche d√©taill√©e pour tester cette fonctionnalit√©.

---

### **1. Pr√©parer le fichier manifeste**
1. Cr√©ez un fichier nomm√© `emptydir-memory.yaml` avec le contenu suivant :

   ```yaml
   apiVersion: v1
   kind: Pod
   metadata:
     name: emptydir-memory-demo
   spec:
     containers:
     - name: monalpine
       image: alpine
       command: ['sh', '-c', 'echo "Fichier en RAM" > /ramvolume/index.html && sleep 600']
       volumeMounts:
       - mountPath: /ramvolume
         name: monvolume
     volumes:
     - name: monvolume
       emptyDir:
         medium: Memory
   ```

2. **Explication du YAML** :
   - **emptyDir** :
     - Attribut `medium: Memory` : Stocke le contenu en RAM (plus rapide mais non persistant).
   - **Container** :
     - Utilise l‚Äôimage `alpine`.
     - √âcrit un fichier `index.html` dans le volume mont√© √† `/ramvolume`.

---

### **2. Appliquer le manifeste**
1. Appliquez le fichier manifeste dans le cluster :
   ```bash
   kubectl apply -f emptydir-memory.yaml
   ```

2. V√©rifiez que le pod est cr√©√© :
   ```bash
   kubectl get pods
   ```

---

### **3. V√©rifier les donn√©es stock√©es en RAM**
1. Acc√©dez au conteneur :
   ```bash
   kubectl exec -it emptydir-memory-demo -- sh
   ```

2. Listez le contenu du volume mont√© en RAM :
   ```bash
   ls /ramvolume
   ```

3. Lisez le fichier cr√©√© :
   ```bash
   cat /ramvolume/index.html
   ```

   Vous devriez voir : `Fichier en RAM`.

### **5. Nettoyage**
1. Supprimez le pod apr√®s les tests :
   ```bash
   kubectl delete -f emptydir-memory.yaml
   ```

---

### **Points importants**
- **Utilisation typique** : Cache temporaire, stockage √©ph√©m√®re rapide.
- **Limitation** :
  - Non persistant.
  - Limit√© par la quantit√© de RAM disponible sur le n≈ìud.
- **Avantage** : Performances accrues par rapport au stockage sur disque.


# Le volume type HostPath partag√© entre pods au niveaux d'un neoud

Voici une d√©marche d√©taill√©e pour tester l'exemple de **hostPath** fourni dans le manifeste.

### ** Sc√©nario : Partage de Donn√©es entre Deux Pods Diff√©rents avec `hostPath`**  

#### ** Id√©e principale**  
Nous avons **deux Pods distincts** :
1Ô∏è **`writer-pod`** √©crit un message dans un fichier partag√© (`/data/shared/message.txt`).  
2Ô∏è **`reader-pod`** lit ce fichier et affiche son contenu.  

üíæ Ces Pods partagent un **volume `hostPath`**, qui est un dossier sur l‚Äôh√¥te (le n≈ìud Kubernetes). Cela permet aux deux Pods d‚Äôacc√©der aux m√™mes fichiers.  

---

## **1Ô∏è Manifest du `writer-pod`**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: writer-pod
spec:
  containers:
  - name: writer
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - echo "Hello from writer-pod!" > /data/shared/message.txt;
        sleep 3600;
    volumeMounts:
    - name: shared-storage
      mountPath: /data/shared
  volumes:
  - name: shared-storage
    hostPath:
      path: /mnt/data  # Chemin partag√© sur le n≈ìud Kubernetes
      type: DirectoryOrCreate
```

---

## **2Ô∏è Manifest du `reader-pod`**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: reader-pod
spec:
  containers:
  - name: reader
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - sleep 5;
        cat /data/shared/message.txt;
        sleep 3600;
    volumeMounts:
    - name: shared-storage
      mountPath: /data/shared
  volumes:
  - name: shared-storage
    hostPath:
      path: /mnt/data  # M√™me chemin que dans `writer-pod`
      type: DirectoryOrCreate
```

---

## ** D√©ploiement & Test**
1Ô∏è **Cr√©er et lancer les Pods :**
```bash
kubectl apply -f writer-pod.yaml
kubectl apply -f reader-pod.yaml
```

2Ô∏è **V√©rifier que les Pods sont en cours d‚Äôex√©cution :**
```bash
kubectl get pods
```

3Ô∏è **Voir les logs du `reader` pour v√©rifier la communication :**
```bash
kubectl logs reader-pod
```
** R√©sultat attendu :**  
```
Hello from writer-pod!
```

---

## ** Pourquoi utiliser `hostPath` ?**
- **Pas besoin de PersistentVolume / PersistentVolumeClaim** .  
- **Les Pods peuvent partager directement des fichiers via le n≈ìud Kubernetes**.  
- **Utile pour des tests en local avec Minikube** .  

