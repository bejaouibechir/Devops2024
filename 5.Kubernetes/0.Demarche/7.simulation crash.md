### ** Simulations de Crash de Pods et Techniques de R√©paration en Kubernetes**  

Voici `trois sc√©narios les plus courants de crash`  lors de la cr√©ation des Pods et **les solutions** pour les r√©parer.

---

## **1Ô∏è Sc√©nario : CrashLoopBackOff (Boucle de red√©marrage)**
 **Probl√®me** : Le Pod entre en boucle de red√©marrage √† cause d'une erreur dans son ex√©cution.  

### ** Simulation : Un Pod avec une commande erron√©e**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: crash-loop-pod
spec:
  containers:
  - name: faulty-container
    image: busybox
    command: ["/bin/sh", "-c"]
    args: ["exit 1"]  # Le conteneur plante imm√©diatement
```

### ** Solution :**
1Ô∏è V√©rifier les logs pour comprendre le probl√®me :  
   ```bash
   kubectl logs crash-loop-pod
   ```
2Ô∏è V√©rifier l‚Äô√©tat du Pod :
   ```bash
   kubectl describe pod crash-loop-pod
   ```
3Ô∏è Modifier la commande dans le manifest YAML pour √©viter l'erreur.  
   Exemple : Remplacer `"exit 1"` par une boucle d'attente (`sleep 3600`).  
4Ô∏è Supprimer et recr√©er le Pod corrig√© :
   ```bash
   kubectl delete pod crash-loop-pod
   kubectl apply -f crash-loop-pod.yaml
   ```

---

## **2Ô∏è Sc√©nario : ImagePullBackOff (Erreur lors du t√©l√©chargement de l'image)**
üí• **Probl√®me** : Kubernetes ne trouve pas l‚Äôimage Docker, souvent √† cause d‚Äôune faute de frappe ou d‚Äôune image priv√©e sans credentials.

### ** Simulation : Un Pod avec une image inexistante**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: image-error-pod
spec:
  containers:
  - name: bad-image
    image: myrepo/doesnotexist:latest  # Image inexistante
```

### **üõ†Ô∏è Solution :**
1Ô∏è V√©rifier l‚Äô√©tat du Pod :
   ```bash
   kubectl describe pod image-error-pod
   ```
2Ô∏è Corriger l‚Äôimage dans le YAML (v√©rifier le bon tag, l‚Äôorthographe, etc.).
3Ô∏è Si l‚Äôimage est priv√©e, cr√©er un secret Docker :
   ```bash
   kubectl create secret docker-registry my-secret \
     --docker-username=monuser \
     --docker-password=monpassword \
     --docker-server=monregistry
   ```
   Puis ajouter ce secret dans le Pod :
   ```yaml
   imagePullSecrets:
   - name: my-secret
   ```
4Ô∏è Supprimer et red√©ployer le Pod :
   ```bash
   kubectl delete pod image-error-pod
   kubectl apply -f image-error-pod.yaml
   ```

---

## **3Ô∏è Sc√©nario : OOMKilled (D√©passement de la m√©moire allou√©e)**
 **Probl√®me** : Le Pod consomme trop de m√©moire et est tu√© par Kubernetes.

### ** Simulation : Un Pod qui consomme trop de m√©moire**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: memory-hungry-pod
spec:
  containers:
  - name: memory-eater
    image: busybox
    command: ["/bin/sh", "-c"]
    args: ["tail -f /dev/zero"]  # Remplit la RAM ind√©finiment
    resources:
      limits:
        memory: "20Mi"  # Limite de m√©moire trop basse
```

### ** Solution :**
1Ô∏è V√©rifier les logs :
   ```bash
   kubectl logs memory-hungry-pod
   ```
2Ô∏è V√©rifier l‚Äô√©tat du Pod :
   ```bash
   kubectl describe pod memory-hungry-pod
   ```
   ** R√©sultat attendu :**
   ```
   Status: OOMKilled
   ```
3Ô∏è Augmenter la m√©moire allou√©e :
   ```yaml
   resources:
     limits:
       memory: "500Mi"
   ```
4Ô∏è Supprimer et red√©ployer le Pod :
   ```bash
   kubectl delete pod memory-hungry-pod
   kubectl apply -f memory-hungry-pod.yaml
   ```

---

### ** R√©capitulatif des Techniques de R√©paration**
| Sc√©nario | Cause | Solution |
|----------|-------|----------|
| **CrashLoopBackOff** | Erreur dans la commande du conteneur | V√©rifier les logs, corriger la commande et red√©ployer |
| **ImagePullBackOff** | Image Docker introuvable | V√©rifier l‚Äôimage, configurer `imagePullSecrets` si n√©cessaire |
| **OOMKilled** | Trop de m√©moire consomm√©e | Augmenter les limites de m√©moire (`resources.limits.memory`) |

