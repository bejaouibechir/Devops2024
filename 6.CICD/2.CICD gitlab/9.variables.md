## 1) Variables CI/CD intégrées (scope pipeline/job)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

show_builtins:
  stage: show
  script:
    - echo "Projet = $CI_PROJECT_PATH"
    - echo "Branche = $CI_COMMIT_REF_NAME"
    - echo "Pipeline = $CI_PIPELINE_ID"
    - echo "Job = $CI_JOB_NAME"
```

---

## 2) Variables définies dans le pipeline (scope global .gitlab-ci.yml)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

variables:
  APP_NAME: "demo-app"
  DEPLOY_ENV: "staging"

show_global_vars:
  stage: show
  script:
    - echo "APP_NAME=$APP_NAME"
    - echo "DEPLOY_ENV=$DEPLOY_ENV"
```

---

## 3) Variables définies au niveau d’un job (scope job uniquement)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [test, show]

test_job:
  stage: test
  variables:
    MODE: "test"
  script:
    - echo "Dans test_job MODE=$MODE"

show_job:
  stage: show
  script:
    - echo "Dans show_job MODE=$MODE"   # vide (MODE n'existe pas ici)
```

---

## 4) Variable “injected” via l’interface GitLab (Settings > CI/CD > Variables)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

show_ui_var:
  stage: show
  script:
    - echo "TOKEN_API=$TOKEN_API"
```

Dans GitLab, créer la variable **TOKEN_API** (masquée/protégée si besoin).
Le job affiche sa valeur (ou "***" si masquée selon contexte runner/log).

---

## 5) Variables protégées (scope branches/tags protégés)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

show_protected:
  stage: show
  script:
    - echo "SECRET_PROD=$SECRET_PROD"
```

Dans GitLab, créer **SECRET_PROD** en mode *Protected*.
Résultat attendu :

* sur main (protégée) → variable dispo
* sur dev (non protégée) → variable absente

---

## 6) Variables d’environnement “environment:” (scope environnement)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [deploy]

deploy_staging:
  stage: deploy
  environment:
    name: staging
  script:
    - echo "DEPLOY_KEY=$DEPLOY_KEY"

deploy_prod:
  stage: deploy
  environment:
    name: production
  script:
    - echo "DEPLOY_KEY=$DEPLOY_KEY"
```

Dans GitLab, créer **DEPLOY_KEY** avec scope d’environnement :

* staging → valeur A
* production → valeur B

---

## 7) Variables “rules” selon contexte (scope pipeline, décidées à l’exécution)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

show_by_branch:
  stage: show
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        TARGET: "prod"
    - if: '$CI_COMMIT_BRANCH != "main"'
      variables:
        TARGET: "dev"
  script:
    - echo "TARGET=$TARGET"
```

---

## 8) Variables passées à la main au lancement (Run pipeline / trigger)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

show_manual:
  stage: show
  script:
    - echo "VERSION=$VERSION"
    - echo "FEATURE_FLAG=$FEATURE_FLAG"
```

Au lancement du pipeline, renseigner **VERSION** et **FEATURE_FLAG**.

---

## 9) “Héritage” et override simple (priorité)

Créer le fichier **.gitlab-ci.yml** :

```yaml
stages: [show]

variables:
  MODE: "global"

job_a:
  stage: show
  script:
    - echo "job_a MODE=$MODE"

job_b:
  stage: show
  variables:
    MODE: "job"
  script:
    - echo "job_b MODE=$MODE"
```

Résultat : job_a → global, job_b → job.

---

Si tu veux un mini-projet démo (avec 3 branches main/dev + variables protégées + scope environnement) je te le donne en scripts complets.
