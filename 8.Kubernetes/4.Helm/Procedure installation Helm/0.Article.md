# **Helm, c’est quoi ?**

Helm est le **gestionnaire de packages pour Kubernetes**.  
Il fonctionne comme `apt` pour Ubuntu ou `yum` pour CentOS ou encore comme `npm` pour javascript ou `nugget` pour .Net, mais pour des applications **K8s**.

---

# **À quoi ça sert ?**

Helm te permet de :

1. **Déployer une application complexe en une seule commande.**
2. **Paramétrer dynamiquement** (via `values.yaml`) sans modifier les fichiers YAML ce qui augemente la chance de reutilisabilité. Réutiliser tes templates YAML comme des **"rôles" (Ansible)** gain de temps énorme.
   
3. **Versionner**, **mettre à jour** ou **supprimer proprement** un déploiement. Donc reduit la complexité de maintenance et de versioning
4. Parfaitement adapté à l'agitité et les process CI/CD

D'accord, commençons par un **exemple complet de déploiement d'une application Nginx sur Kubernetes**, d'abord sans **Helm**, puis avec **Helm**, pour que vous puissiez bien comparer les deux approches. Nous allons couvrir les étapes du déploiement en utilisant un fichier Kubernetes standard et ensuite avec Helm pour voir la différence.

Pour mieux comprendre helm essayons un avec un scenario basique.

Tout d'abord nous essayons de déployer une simple application nginx sans **Helm** 

Puis nous passons à une deuxième alterntive là ou nous allons utiliser **Helm** pour arriver à la même fin


### 1. **Sans Helm : Déploiement manuel sur Kubernetes**

#### Étape 1 : Créer un fichier de déploiement Kubernetes (Nginx)

Créez un fichier nommé `nginx-deployment.yaml` qui définit un déploiement Nginx avec un service exposé via un `NodePort`.

```yaml
# nginx-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080
  selector:
    app: nginx
```

#### Explication :

1. **Déploiement** :
   - Nous créons un déploiement de 3 réplicas d'une application Nginx avec l'image `nginx:latest`.
   - Le conteneur écoute sur le port `80`.

2. **Service** :
   - Le service est de type `NodePort`, ce qui signifie qu'il sera exposé sur un port spécifique de vos nœuds Kubernetes (ici `30080`).
   - Le service redirige le trafic sur le port `80` vers les pods Nginx.

#### Étape 2 : Appliquer le fichier YAML

Pour appliquer le fichier de déploiement sur Kubernetes, utilisez la commande suivante :

```bash
kubectl apply -f nginx-deployment.yaml
```

Cela va créer le déploiement et le service Nginx sur votre cluster Kubernetes.

#### Étape 3 : Vérifier l’état des ressources

Vérifions que les pods et le service ont été créés correctement :

```bash
kubectl get pods
kubectl get svc
```

Cela devrait nous afficher quelque chose comme ceci pour les pods et le service :

```
NAME                                  READY   STATUS    RESTARTS   AGE
nginx-deployment-5f68fdb7bd-abcde     1/1     Running   0          3m
nginx-deployment-5f68fdb7bd-fghij     1/1     Running   0          3m
nginx-deployment-5f68fdb7bd-klmno     1/1     Running   0          3m

NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
nginx-service     NodePort    10.104.1.1      <none>        80:30080/TCP   3m
```

#### Étape 4 : Accéder à l’application

Accédons à l’application en utilisant l'adresse IP de votre nœud Kubernetes et le port `30080` (comme spécifié dans le fichier de service). Nous pouvons obtenir l'IP du nœud avec la commande suivante :

```bash
kubectl get nodes -o wide
```

Puis, ouvrez un navigateur et accédez à :

```
http://<IP_du_nœud>:30080
```

---

### 2. **Avec Helm : Création d'un Chart personnalisé pour Nginx**

Maintenant, voyons comment nous allons accomplir la même chose avec **Helm**. Nous allons créer un chart personnalisé pour déployer Nginx.

#### Étape 1 : Créer un nouveau Chart Helm

Utilisez la commande Helm pour créer la structure de base d'un chart :

```bash
helm create nginx-chart
```

Cela crée un répertoire `nginx-chart` avec la structure suivante :

```
nginx-chart/
├── Chart.yaml
├── values.yaml
├── charts/
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   └── hpa.yaml
└── README.md
```

#### Étape 2 : Modifier les fichiers de configuration

##### 1. **Modifier le fichier `Chart.yaml`**

Ouvrez le fichier `Chart.yaml` et personnalisez-le :

```yaml
apiVersion: v2
name: nginx
description: A Helm chart for Kubernetes to deploy Nginx
version: 0.1.0
```

##### 2. **Modifier le fichier `values.yaml`**

Dans `values.yaml`, définissez les paramètres pour le déploiement, comme le nombre de réplicas et le port du service :

```yaml
replicaCount: 3

image:
  repository: nginx
  tag: "latest"
  pullPolicy: IfNotPresent

service:
  type: NodePort
  port: 80
  nodePort: 30080
```

Cela configure un service de type **NodePort** qui sera exposé sur le port `30080`.

##### 3. **Modifier le fichier `deployment.yaml` dans `templates/`**

Le fichier `templates/deployment.yaml` définit le déploiement Nginx. Il ressemble à ceci :

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "nginx.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "nginx.name" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app.kubernetes.io/name: {{ include "nginx.name" . }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include "nginx.name" . }}
    spec:
      containers:
        - name: nginx
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: 80
```

##### 4. **Modifier le fichier `service.yaml` dans `templates/`**

Le fichier `templates/service.yaml` expose l’application via un `NodePort` :

```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "nginx.fullname" . }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: 80
      nodePort: {{ .Values.service.nodePort }}
  selector:
    app.kubernetes.io/name: {{ include "nginx.name" . }}
```

#### Étape 3 : Déployer avec Helm

Pour déployer le chart Helm, exécutez la commande suivante dans le répertoire du chart :

```bash
helm install my-nginx ./nginx-chart
```

Cela déploie l’application Nginx avec 3 réplicas et un service de type **NodePort** exposé sur le port `30080`.

#### Étape 4 : Vérifier les ressources

Vérifiez que tout a bien été créé en exécutant :

```bash
kubectl get all
```

Cela affichera les pods et le service, similaires à ce que nous avons vu précédemment.

#### Étape 5 : Accéder à l’application

De la même manière qu'avec le déploiement manuel, vous pouvez accéder à l'application via l'IP de votre nœud Kubernetes et le port `30080`.

---

### 3. **Comparaison : Sans Helm vs Avec Helm**

#### **Sans Helm** :
- Vous gérez manuellement les fichiers YAML (`deployment.yaml`, `service.yaml`).
- Vous appliquez les fichiers via `kubectl apply -f`.
- Pas de gestion de versions, de configuration dynamique ni de paramétrage facile.

#### **Avec Helm** :
- Vous utilisez un chart pré-configuré pour simplifier le déploiement.
- Vous pouvez paramétrer le chart avec des valeurs personnalisées dans `values.yaml`.
- Helm facilite les mises à jour avec la commande `helm upgrade`.
- Vous pouvez réutiliser et partager facilement des charts.

---

### Conclusion

L'utilisation de **Helm** simplifie la gestion de vos déploiements Kubernetes en fournissant une approche paramétrée et réutilisable. Cela devient particulièrement utile pour les déploiements plus complexes ou lorsque vous devez gérer plusieurs environnements.

Si vous avez des questions ou si vous souhaitez approfondir un aspect particulier de Helm, n'hésitez pas à demander !