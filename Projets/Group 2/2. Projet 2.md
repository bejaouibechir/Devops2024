# DÃ©ploiement dâ€™une Application CRUD ConteneurisÃ©e en Architecture Trois Couches avec .NET et PostgreSQL

### **Objectif du Projet**  
Lâ€™objectif de ce projet est de mettre en place une **application CRUD** complÃ¨te permettant la gestion des employÃ©s (**Employee Management System**) en utilisant une architecture trois couches. Lâ€™application sera dÃ©veloppÃ©e en **.NET Web API** pour la couche mÃ©tier, **PostgreSQL** pour la base de donnÃ©es, et une **interface web en HTML/CSS/JavaScript** pour lâ€™affichage.  

Afin dâ€™assurer une **automatisation complÃ¨te du dÃ©ploiement**, nous allons :  
 1. Conteneuriser chaque couche avec **Docker**  
 2. Orchestrer les services avec **Docker Compose**  
 3. Automatiser lâ€™installation avec **Ansible**  
 4. Mettre en place un pipeline **CI/CD avec Jenkins**  

---

### **Architecture du Projet**  
Lâ€™application repose sur trois couches distinctes :  
1. **Couche Base de DonnÃ©es** : PostgreSQL avec une table `employees` contenant les informations des employÃ©s.  
2. **Couche MÃ©tier** : Une API REST en **.NET Web API** permettant dâ€™effectuer les opÃ©rations CRUD.  
3. **Couche PrÃ©sentation** : Une interface utilisateur en **HTML/CSS/JavaScript** interagissant avec lâ€™API via AJAX.  

Lâ€™ensemble sera dÃ©ployÃ© sur des serveurs distants orchestrÃ©s avec **Ansible**, et les images Docker seront gÃ©rÃ©es via **Docker Hub**.  

---
#### **SchÃ©ma DevOps**

```plaintext
Git ---> GitLab ---> sv1:Jenkins (avec Jenkinsfile) ---> sv1:Ansible ---> sv2:Docker (Install Docker with Playbook) : application conteneurisÃ©e
```

Si cette introduction te convient, je peux maintenant l'intÃ©grer dans un document avec le reste du projet. Tu veux que je l'ajoute dans un fichier Markdown ou un autre format ? ðŸ“„
### **Nouvelle Structure du Projet**
```plaintext
project/
â”œâ”€â”€ backend/                  # .NET Web API
â”‚   â”œâ”€â”€ EmployeeAPI/          # Projet API
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ EmployeeAPI.sln       # Solution .NET
â”œâ”€â”€ frontend/                 # Interface utilisateur (HTML/CSS/JS)
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ style.css
â”‚   â”œâ”€â”€ app.js
â”‚   â””â”€â”€ Dockerfile
â””â”€â”€ database/                 # Base de donnÃ©es PostgreSQL
    â”œâ”€â”€ init.sql
    â””â”€â”€ Dockerfile
```

---

### **1. Base de DonnÃ©es - PostgreSQL**
#### **`init.sql`**
```sql
\c employee_db;

CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    position VARCHAR(100) NOT NULL,
    salary DECIMAL(10, 2) NOT NULL
);
```

#### **`Dockerfile` pour PostgreSQL**
```dockerfile
FROM postgres:15
ENV POSTGRES_DB=employee_db
ENV POSTGRES_USER=admin
ENV POSTGRES_PASSWORD=admin
COPY init.sql /docker-entrypoint-initdb.d/
```

---

### **2. Backend - .NET Web API**
On va crÃ©er un projet **ASP.NET Core Web API** qui expose des endpoints CRUD pour l'entitÃ© **Employee**.

#### **Commandes pour gÃ©nÃ©rer le projet :**
```sh
dotnet new webapi -n EmployeeAPI
cd EmployeeAPI
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
```

#### **ModÃ¨le `Employee.cs`**
```csharp
public class Employee
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Position { get; set; }
    public decimal Salary { get; set; }
}
```

#### **DbContext `EmployeeDbContext.cs`**
```csharp
using Microsoft.EntityFrameworkCore;

public class EmployeeDbContext : DbContext
{
    public EmployeeDbContext(DbContextOptions<EmployeeDbContext> options) : base(options) { }

    public DbSet<Employee> Employees { get; set; }
}
```

#### **ContrÃ´leur API `EmployeesController.cs`**
```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[Route("api/[controller]")]
[ApiController]
public class EmployeesController : ControllerBase
{
    private readonly EmployeeDbContext _context;

    public EmployeesController(EmployeeDbContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Employee>>> GetEmployees()
    {
        return await _context.Employees.ToListAsync();
    }

    [HttpPost]
    public async Task<ActionResult<Employee>> PostEmployee(Employee employee)
    {
        _context.Employees.Add(employee);
        await _context.SaveChangesAsync();
        return CreatedAtAction(nameof(GetEmployees), new { id = employee.Id }, employee);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutEmployee(int id, Employee employee)
    {
        if (id != employee.Id)
            return BadRequest();

        _context.Entry(employee).State = EntityState.Modified;
        await _context.SaveChangesAsync();

        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteEmployee(int id)
    {
        var employee = await _context.Employees.FindAsync(id);
        if (employee == null)
            return NotFound();

        _context.Employees.Remove(employee);
        await _context.SaveChangesAsync();

        return NoContent();
    }
}
```

#### **Ajout de la configuration PostgreSQL (`appsettings.json`)**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=db;Database=employee_db;Username=admin;Password=admin"
  }
}
```

#### **Ajout de la connexion Ã  PostgreSQL (`Program.cs`)**
```csharp
using Microsoft.EntityFrameworkCore;
using Npgsql.EntityFrameworkCore.PostgreSQL;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddDbContext<EmployeeDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();
app.UseAuthorization();
app.MapControllers();
app.Run();
```

#### **Dockerfile pour .NET Web API**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY . .
ENTRYPOINT ["dotnet", "EmployeeAPI.dll"]
```

---

### **3. Frontend - Interface Utilisateur**
On garde une interface HTML/CSS/JS simple, en modifiant les endpoints pour interagir avec **.NET Web API**.

#### **`app.js`**
```javascript
const apiUrl = 'http://localhost:5000/api/employees';

// Charger les employÃ©s
function loadEmployees() {
    fetch(apiUrl)
        .then(response => response.json())
        .then(employees => {
            const employeeList = document.getElementById('employee-list');
            employeeList.innerHTML = '';

            employees.forEach(employee => {
                const li = document.createElement('li');
                li.textContent = `${employee.firstName} ${employee.lastName} - ${employee.position} (${employee.salary} â‚¬)`;

                const editButton = document.createElement('button');
                editButton.textContent = 'Modifier';
                editButton.onclick = () => editEmployee(employee);

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Supprimer';
                deleteButton.onclick = () => deleteEmployee(employee.id);

                li.appendChild(editButton);
                li.appendChild(deleteButton);

                employeeList.appendChild(li);
            });
        })
        .catch(error => console.error('Erreur lors du chargement:', error));
}

// Ajouter ou modifier un employÃ©
document.getElementById('employee-form').onsubmit = function (event) {
    event.preventDefault();

    const id = document.getElementById('employee-id').value;
    const firstName = document.getElementById('first-name').value;
    const lastName = document.getElementById('last-name').value;
    const position = document.getElementById('position').value;
    const salary = document.getElementById('salary').value;

    const method = id ? 'PUT' : 'POST';
    const url = id ? `${apiUrl}/${id}` : apiUrl;

    fetch(url, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ firstName, lastName, position, salary })
    })
        .then(() => {
            document.getElementById('employee-form').reset();
            loadEmployees();
        })
        .catch(error => console.error('Erreur lors de l\'enregistrement:', error));
};

// Supprimer un employÃ©
function deleteEmployee(id) {
    fetch(`${apiUrl}/${id}`, { method: 'DELETE' })
        .then(() => loadEmployees())
        .catch(error => console.error('Erreur lors de la suppression:', error));
}

loadEmployees();
```
###  ***Dockerfile pour la partie frontend***
``` dockerfile
# Utilisation de Nginx comme serveur web
FROM nginx:alpine

# Copie des fichiers frontend dans le rÃ©pertoire Nginx
COPY . /usr/share/nginx/html

# Expose le port 80
EXPOSE 80

# DÃ©marrage de Nginx
CMD ["nginx", "-g", "daemon off;"]

```
---

### **4. Docker Compose**
#### **`docker-compose.yml`**
```yaml
version: '3.8'
services:
  db:
    build: ./database
    container_name: postgres_db
    ports:
      - "5432:5432"

  backend:
    build: ./backend
    container_name: dotnet_api
    ports:
      - "5000:5000"
    depends_on:
      - db

  frontend:
    build: ./frontend
    container_name: web_app
    ports:
      - "8080:80"
    depends_on:
      - backend
```
