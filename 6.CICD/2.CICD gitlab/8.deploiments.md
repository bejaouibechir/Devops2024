### Scénario 1 — Package Registry (Generic Packages)

```yaml
stages:
  - prepare
  - build
  - publish

# Job 1: crée un fichier source (utilisé par le job suivant)
prepare_source:
  stage: prepare
  image: alpine:3.20
  script:
    - |
      # Création d'un fichier source simple
      printf "Hello from prepare job - %s\n" "$(date -u +"%F %T")" > source.txt
  artifacts:
    # On publie source.txt pour le job suivant
    paths:
      - source.txt
    expire_in: 1 hour

# Job 2: génère l'artefact index.html à partir du fichier source.txt
build_index_html:
  stage: build
  image: alpine:3.20
  needs:
    - job: prepare_source
      artifacts: true
  script:
    - |
      # Génération d'un index.html basé sur le contenu du fichier source
      SRC_CONTENT="$(cat source.txt)"
      cat > index.html <<'HTML'
      <!doctype html>
      <html lang="fr">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>Artefact CI</title>
        </head>
        <body>
          <h1>Artefact GitLab CI</h1>
          <pre id="payload"></pre>
          <script>
            // Le contenu sera injecté côté CI (remplacement simple)
            const payload = "__CI_PAYLOAD__";
            document.getElementById("payload").textContent = payload;
          </script>
        </body>
      </html>
HTML
      # Remplacement du placeholder par le contenu réel (échappement minimal)
      ESCAPED="$(printf "%s" "$SRC_CONTENT" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"
      sed -i "s/__CI_PAYLOAD__/${ESCAPED}/g" index.html
  artifacts:
    # Artefact index.html pour le job publish
    paths:
      - index.html
    expire_in: 1 day

# Job 3: upload index.html vers GitLab Package Registry (Generic Package)
publish_to_package_registry:
  stage: publish
  image: alpine:3.20
  needs:
    - job: build_index_html
      artifacts: true
  script:
    - |
      # Dépendances
      apk add --no-cache curl

      # Paramètres package (nom + version)
      PACKAGE_NAME="web-artefact"
      PACKAGE_VERSION="${CI_COMMIT_SHORT_SHA}"

      # Upload vers Generic Packages via CI_JOB_TOKEN
      # URL: /projects/:id/packages/generic/:package_name/:package_version/:file_name
      curl --fail --show-error --location \
        --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
        --upload-file index.html \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PACKAGE_NAME}/${PACKAGE_VERSION}/index.html"
  rules:
    # Exécution sur branches (ajuste selon besoin)
    - if: $CI_COMMIT_BRANCH
```

---

### Scénario 2 — Déploiement vers machine distante 21.5.23.2 via scp (clé privée dans ID_RSA)

```yaml
stages:
  - prepare
  - build
  - deploy

prepare_source:
  stage: prepare
  image: alpine:3.20
  script:
    - |
      # Création d'un fichier source simple
      printf "Hello from prepare job - %s\n" "$(date -u +"%F %T")" > source.txt
  artifacts:
    paths:
      - source.txt
    expire_in: 1 hour

build_index_html:
  stage: build
  image: alpine:3.20
  needs:
    - job: prepare_source
      artifacts: true
  script:
    - |
      # Génération d'un index.html basé sur le contenu du fichier source.txt
      SRC_CONTENT="$(cat source.txt)"
      cat > index.html <<'HTML'
      <!doctype html>
      <html lang="fr">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>Artefact CI</title>
        </head>
        <body>
          <h1>Artefact GitLab CI</h1>
          <pre id="payload"></pre>
          <script>
            // Le contenu sera injecté côté CI (remplacement simple)
            const payload = "__CI_PAYLOAD__";
            document.getElementById("payload").textContent = payload;
          </script>
        </body>
      </html>
HTML
      # Remplacement du placeholder par le contenu réel (échappement minimal)
      ESCAPED="$(printf "%s" "$SRC_CONTENT" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"
      sed -i "s/__CI_PAYLOAD__/${ESCAPED}/g" index.html
  artifacts:
    paths:
      - index.html
    expire_in: 1 day

deploy_to_remote:
  stage: deploy
  image: alpine:3.20
  needs:
    - job: build_index_html
      artifacts: true
  variables:
    # Ajuste si besoin (utilisateur distant + chemin)
    REMOTE_HOST: "21.5.23.2"
    REMOTE_USER: "ubuntu"
    REMOTE_PATH: "/var/www/html/index.html"
  script:
    - |
      # Outils SSH
      apk add --no-cache openssh-client

      # Prépare la clé privée depuis la variable CI (ID_RSA)
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh

      # Écrit la clé dans un fichier (permissions strictes)
      printf "%s" "$ID_RSA" > ~/.ssh/id_rsa
      chmod 600 ~/.ssh/id_rsa

      # Déploiement via scp
      scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa index.html "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PATH}"
  rules:
    - if: $CI_COMMIT_BRANCH
```
