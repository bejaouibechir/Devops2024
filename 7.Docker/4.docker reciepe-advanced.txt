-------------------------Docker file---------------------------------------------------------

*************************** LABEL *****************************************

# Description : Ajoute des métadonnées à l'image Docker.
FROM ubuntu:latest
LABEL maintainer="admin@example.com"
LABEL version="1.0"
LABEL description="This is a custom Ubuntu image with metadata"

*************************** ARG *****************************************

# Description : Définit une variable pour passer des valeurs lors du docker build.
FROM ubuntu:latest
ARG APP_VERSION=1.0
RUN echo "Application version is ${APP_VERSION}"
ENTRYPOINT["sleep","3600"]

La commande:
docker build --build-arg APP_VERSION=2.0 -t myapp .

*******(COPY) Exemple: Image personnalisée nginx***********************************************************
FROM nginx
LABEL description = "Image personnalisée"
COPY index.html /usr/share/nginx/html/

*******(ADD) Exemple: Image personnalisée nginx***********************************************************
# Add compression
FROM nginx
LABEL description = "Image personnalisée"
ADD web.tar.gz /usr/share/nginx/html/

*******(ADD) Exemple: Image personnalisée nginx***********************************************************
# Add téléchargement
FROM nginx
LABEL description = "Image personnalisée"
ADD https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml  config.yaml

*****WORKDIR*************************************************************************************************
FROM ubuntu
WORKDIR /app
COPY app.py .

*****EXPOSE***************************************************************************************************

FROM nginx
EXPOSE 8080
COPY default.conf  /etc/nginx/conf.d/default.conf

Avec default.conf: 

server {
    listen 8080;                # Port d’écoute interne du conteneur
    server_name _;              # Accepte toutes les requêtes
    root /usr/share/nginx/html; # Répertoire racine des fichiers à servir
    index index.html;           # Fichier d’index par défaut

    location / {
        try_files $uri $uri/ =404;  # Sert le fichier demandé ou renvoie 404
    }
}

********Volume*****************************************************************************

1.VOLUME déclare un point de montage dans l’image (volume anonyme -> chemin)
2.Le mapping réel se fait au docker run

Ordre des instructions : COPY avant VOLUME !
	Dès que VOLUME est déclaré sur /data, tout écrit ultérieur vers /data ne sera plus dans une couche de l’image, 
	mais redirigé vers le volume au runtime.

	Donc pour initialiser un volume avec des fichiers,COPY doit être executé avant VOLUME, ou bien utiliser 
	une autre stratégie (init container, script d’entrée, etc.).

exemple:
default.conf:
server {
    listen 8080;                   # Nginx écoute sur 8080
    server_name _;                 # Accepte tout host
    root /usr/share/nginx/html;    # Racine web (sera montée en volume)
    index index.html;
    location / { try_files $uri $uri/ =404; }
}
index.html :
<!DOCTYPE html>
<html>
  <head><meta charset="utf-8"><title>Nginx + VOLUME</title></head>
  <body>
    <h1>Contenu initial copié dans l'image (avant VOLUME)</h1>
  </body>
</html>
Dockerfile:

FROM nginx

COPY default.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/index.html

VOLUME ["/etc/nginx/conf.d"]
VOLUME ["/usr/share/nginx/html"]

EXPOSE 8080


****ENV***********************************************************************************

Dockerfile:
# Image de base minimale
FROM debian:bookworm-slim

# Définition de variables d'environnement par défaut (surchargables au runtime)
# UTILISATEUR: admin | MOT DE PASSE: secret123
ENV LOGIN=admin \
    PASSWORD=secret123

# Copie du script d'application dans l'image
COPY app.sh /usr/local/bin/app.sh

# Rend le script exécutable
RUN chmod +x /usr/local/bin/app.sh

# Exécute le script au démarrage du conteneur
ENTRYPOINT ["/usr/local/bin/app.sh"]

script bash:

#!/usr/bin/env bash
# Activer des options strictes :
# -e : stoppe en cas d'erreur
# -u : erreur si variable non définie
# -o pipefail : propage l'échec dans un pipeline
set -euo pipefail

# --- Paramètres attendus ---
# Les variables d'environnement LOGIN et PASSWORD sont fournies par l'image (ENV dans le Dockerfile)
# et peuvent être surchargées à l'exécution via `docker run -e LOGIN=... -e PASSWORD=...`.

# --- Référentiel d'authentification (fictif pour la démo) ---
# Valeurs "correctes" codées en dur uniquement pour la démonstration
EXPECTED_LOGIN="admin"
EXPECTED_PASSWORD="secret123"

# --- Lecture sécurisée des variables d'environnement ---
LOGIN_VALUE="${LOGIN:-}"
PASSWORD_VALUE="${PASSWORD:-}"

# --- Contrôles préalables ---
# Vérifie que les deux variables sont bien présentes et non vides
if [[ -z "$LOGIN_VALUE" || -z "$PASSWORD_VALUE" ]]; then
  echo "Erreur : variables d'environnement requises : LOGIN et PASSWORD."
  echo "Exemple : docker run --rm -e LOGIN=admin -e PASSWORD=secret123 image"
  exit 2
fi

# --- Validation des identifiants ---
# Compare les valeurs fournies avec les valeurs attendues
if [[ "$LOGIN_VALUE" == "$EXPECTED_LOGIN" && "$PASSWORD_VALUE" == "$EXPECTED_PASSWORD" ]]; then
  echo "Authentification réussie : accès autorisé."
  # Ici on lancerait l'application réelle (ex.: exec /usr/bin/mon-app ...)
  exit 0
else
  echo "Authentification échouée : accès refusé."
  exit 1
fi


***********User*********************************************************************************

Dockerfile:
# Image minimale
FROM alpine:3.20

# Créer un utilisateur non-root simple
RUN adduser -D -h /home/appuser appuser

# Préparer les dossiers d'app et de données
RUN mkdir -p /app /data && chown -R appuser:appuser /app /data

# Copier le script d'application
COPY app.sh /app/app.sh
RUN chmod +x /app/app.sh

# Exécuter en non-root
USER appuser
WORKDIR /app

# Lancer le script
ENTRYPOINT ["/app/app.sh"]

app.sh :

#!/bin/sh
# Démo USER : ce script tourne en non-root
set -eu

# Afficher l'identité effective
echo "Utilisateur : $(whoami)"
echo "UID:GID    : $(id -u):$(id -g)"

# Tester une écriture dans un répertoire possédé par appuser
echo "hello from $(whoami)" > /data/ok.txt
echo "Fichier créé : /data/ok.txt"

Commande:
docker logs <nom du conteneur>


****Exemple 4 la commande CMD********************************************************************

FROM ubuntu AS linux
CMD ["ls", "-al"]
 
CMD interrompe la continuité d'exécution  du conteneur
docker logs conteneur
                       
 ***************** CMD vs EntryPoint ********************

#Dockerfile qui utilise ENTRYPOINT

FROM  ubuntu as image-ep
ENTRYPOINT ["echo","Hello"]
CMD ["World"]


#Dockerfile qui utilise CMD

FROM  ubuntu as image-cmd
CMD ["echo","Hello","World"]

docker run imgep Bechir
docker run imgcmd Bechir <- error

#executer sans paramètres
docker run imgep
ou
#ecraser carrément la commande
docker run imgep ls -l

*************************** WORKDIR *****************************************

Description : Définit le répertoire de travail.

dockerfile
Copy
Edit
FROM ubuntu:latest
WORKDIR /app
RUN touch file.txt
CMD ["ls", "-l"]

*************************** ENV *****************************************

Description : Définit des variables d'environnement disponibles à l'exécution.

dockerfile
Copy
Edit
FROM ubuntu:latest
ENV APP_ENV=production
ENV APP_PORT=8080
CMD echo "Running in ${APP_ENV} on port ${APP_PORT}"

*************************** EXPOSE *****************************************

Description : Expose un port pour les communications.

dockerfile
Copy
Edit
FROM nginx:latest
EXPOSE 8080
CMD ["nginx", "-g", "daemon off;"]

*************************** VOLUMES *****************************************

Description : Montre un volume pour persister les données.

dockerfile
Copy
Edit
FROM ubuntu:latest
VOLUME /data
CMD ["echo", "Data is stored in /data"]

*************************** USER *****************************************

Description : Définit l'utilisateur d'exécution.

dockerfile
Copy
Edit
FROM ubuntu:latest
RUN useradd -m customuser
USER customuser
CMD ["whoami"]

*******FROM multiple images***********************************************************

FROM ubuntu AS linux

# taper le reste des détails

FROM nginx AS webserver

# taper le reste des détails

Exemple pour créer une image ubuntu 
docker build -t myLinux --target linux . 

Exemple pour créer une image nginx 
docker build -t myLinux --target webserver . 

***************Exemple application python avec flask**********************************

app.py

from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
	return "Hello World!"

if __name__ == '__main__':
	app.run(host='0.0.0.0', port=8000)

requirements.txt
flask


FROM python

WORKDIR /app

COPY requirements.txt /app

RUN --mount=type=cache,target=/root/.cache/pip \
    pip3 install -r requirements.txt


COPY app.py /app

EXPOSE 8000

ENTRYPOINT ["python3"]
CMD ["app.py"]


***************************************** **Exemple  : Application Flask + Redis** ************************************

### **Description :**
Une application Flask utilisant Redis comme cache.

#### **Code source :**
**app.py** :
```python
from flask import Flask
import redis

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)

@app.route('/')
def hit_counter():
    count = cache.incr('hits')
    return f"Hello! This page has been visited {count} times."

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

#### **Dockerfile :**
**Dockerfile** :
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY app.py .
RUN pip install flask redis
CMD ["python", "app.py"]
```

#### **Docker Compose File :**
**docker-compose.yml** :
```yaml
version: "3.9"
services:
  flask:
    build: .
    ports:
      - "5000:5000"
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
```

#### **Commandes de test :**
```bash
docker-compose up -d
curl http://localhost:5000
```

---

***************************************** **Exemple  : MySQL avec Adminer** ************************************

### **Description :**
Déployer une base de données MySQL avec une interface Adminer.

#### **Docker Compose File :**
**docker-compose.yml** :
```yaml
version: "3.9"
services:
  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: example
      MYSQL_DATABASE: testdb
    ports:
      - "3306:3306"

  adminer:
    image: adminer:latest
    ports:
      - "8080:8080"
```

#### **Commandes de test :**
1. Lancer les services :
   ```bash
   docker-compose up -d
   ```
2. Accéder à Adminer :
   - URL : `http://localhost:8080`
   - Utilisateur : `root`
   - Mot de passe : `example`

---

***************************************** **Exemple  : Application MEAN (MongoDB + Node.js + Angular)** ************************************

### **Description :**
Créer un environnement complet MEAN (MongoDB, Express, Angular, Node.js).

#### **Code source :**
**server.js** (Node.js backend) :
```javascript
const express = require('express');
const mongoose = require('mongoose');
const app = express();

mongoose.connect('mongodb://mongo:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

app.get('/', (req, res) => {
    res.send("Hello from Node.js with MongoDB!");
});

app.listen(3000, () => console.log('Server running on port 3000'));
```

#### **Dockerfile :**
**Dockerfile** :
```dockerfile
FROM node:14
WORKDIR /app
COPY server.js .
RUN npm install express mongoose
CMD ["node", "server.js"]
```

#### **Docker Compose File :**
**docker-compose.yml** :
```yaml
version: "3.9"
services:
  backend:
    build: .
    ports:
      - "3000:3000"

  mongo:
    image: mongo:latest
    ports:
      - "27017:27017"
```

#### **Commandes de test :**
1. Lancer les services :
   ```bash
   docker-compose up -d
   ```
2. Tester l'API :
   ```bash
   curl http://localhost:3000
   ```


-------------------------publish--------------------------------------------------------

 *************Publication vers docker hub********************************

 #login to the hub
 docker login -u "bechirbejaoui" -p "docker1234@"
 #tag the image
 docker tag myapp  bechirbejaoui/myapp:latest
 #push the image 
 docker push bechirbejaoui/myapp:latest

************Publication vers Azure container*****************************

Install Az cli on windows:
https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=winget
install with Winget (third tab)
winget install -e --id Microsoft.AzureCLI


**************************Install Az cli en linux:*******************************************

sudo apt-get update
sudo apt-get install ca-certificates curl apt-transport-https lsb-release gnupg
sudo mkdir -p /etc/apt/keyrings
curl -sLS https://packages.microsoft.com/keys/microsoft.asc |gpg --dearmor |sudo tee /etc/apt/keyrings/microsoft.gpg > /dev/null
sudo chmod go+r /etc/apt/keyrings/microsoft.gpg
AZ_DIST=$(lsb_release -cs)
echo "deb [arch=`dpkg --print-architecture` signed-by=/etc/apt/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ $AZ_DIST main" |sudo tee /etc/apt/sources.list.d/azure-cli.list
sudo apt-get update
sudo apt-get install azure-cli
az --version

In Azure portal:

Then 
azure  acr login --name  <nom acr> 
enter 
Access KeysinAzure then get username & password 
connect

docker tag <nom image> <nom acr>/<nom image>
docker push <nom acr>/<nom image>


************Publication vers Gitlab*****************************

Create a  PersonalToken with enough rights

docker tag image /project/group/projectname/image

docker push /project/group/projectname/image


************CI CD Gitlab*****************************
https://www.youtube.com/watch?v=7I6tHw68DMQ

build image: 
  image: docker
  services:
    - docker:dind
  script:
    -  docker build -t mysqlimage db/.
    -  echo "image has been built successfully"
    -  docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
      OR
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY  --password-stdin
    -  docker 
    -  docker build -t image_name path 
    -  docker tag image_name $CI_REGISTRY/CI_PROJECT_NAME/image_name
    -  docker push $CI_REGISTRY/CI_PROJECT_NAME/image_name

others:

bechir888
EyZZkgZK?.6jdWZ
docker build -t registry.gitlab.com/bechir-test-group/dockerproject .
glpat-UpDFsghgzVxzuhBs_LYg
docker login  -u bechir888 registry.gitlab.com  --password-stdin
docker login registry.gitlab.com
docker tag mysqlimg registry.gitlab.com/bechir-test-group/dockerproject/mysqlimg
docker build -t registry.gitlab.com/bechir-test-group/dockerproject .
docker push registry.gitlab.com/bechir-test-group/dockerproject

-------------------------Buildah-------------------------------------------------------
sudo apt install buildah

    buildah --version or -v
    buildah images
    buildah containers
    container1 =$(buildah from fedora)
    echo $container1
    buildah run $container1 bash
    buildah run $container1 java
    buildah run $container1 -- dnf -y install httpd
    buildah run $container httpd
    


# Base on the most recently released Fedora
FROM fedora:latest
MAINTAINER ipbabble email buildahboy@redhat.com # not a real email

# Install updates and httpd
RUN echo "Updating all fedora packages"; dnf -y update; dnf -y clean all
RUN echo "Installing httpd"; dnf -y install httpd && dnf -y clean all

# Expose the default httpd port 80
EXPOSE 80

# Run the httpd
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]

buildah build -t fedora-http-server
















