# Partie 0 - Les limites de configmap en cas de stockage des informations sensibles
 
 voici un **sc√©nario concret et d√©monstratif** qui montre **pourquoi un `ConfigMap` ne doit jamais √™tre utilis√© pour stocker des donn√©es sensibles**, m√™me si on encode les donn√©es en Base64.

## ‚ö† **Sc√©nario ‚Äì Le pi√®ge de l'encodage dans un ConfigMap**

###  Objectif :

Montrer que **l'encodage Base64 dans un ConfigMap ne prot√®ge pas les donn√©es sensibles**, et qu‚Äôelles peuvent √™tre facilement r√©cup√©r√©es par n‚Äôimporte qui ayant acc√®s au cluster.

###  √âtapes du sc√©nario :

#### 1. üõ† Cr√©er un fichier `configmap-unsafe.yaml` :

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-config
data:
  # Faux sentiment de s√©curit√© : encodage base64 "√† la main"
  db_user: YWRtaW4=         # Base64 de "admin"
  db_password: cGFzc3dvcmQxMjM= # Base64 de "password123"
```

#### 2.  Appliquer le ConfigMap :

```bash
kubectl apply -f configmap-unsafe.yaml
```

#### 3.  Lire le contenu du ConfigMap :

```bash
kubectl get configmap db-config -o yaml
```

R√©sultat affich√© :

```yaml
data:
  db_user: YWRtaW4=
  db_password: cGFzc3dvcmQxMjM=
```

#### 4.  D√©crypter facilement avec une seule commande shell :

```bash
echo "YWRtaW4=" | base64 --decode      # admin
echo "cGFzc3dvcmQxMjM=" | base64 --decode  # password123
```

---

###  **Conclusion** :

* **Erreur fr√©quente** : croire qu‚Äôun encodage base64 "prot√®ge" les secrets.
* En r√©alit√©, n‚Äôimporte quel utilisateur ayant acc√®s au cluster (et aux ConfigMaps) peut **r√©cup√©rer les donn√©es sensibles en clair** avec un simple `kubectl get` et un `base64 --decode`.

---

###  **Recommandation** :

‚û°Ô∏è Pour les donn√©es sensibles, **utilisez toujours un `Secret`** :

* Son contenu est √©galement encod√© en base64‚Ä¶
* **Mais** :

  * Il est marqu√© comme **type=Opaque**.
  * Il est souvent **filtr√© dans les outils de visualisation (Dashboard, Lens, etc.)**.
  * Il peut √™tre **int√©gr√© avec des solutions de gestion de secrets s√©curis√©es** (Vault, KMS, etc.).
  * Les r√¥les Kubernetes (`RBAC`) peuvent **restreindre l‚Äôacc√®s aux Secrets**, contrairement aux ConfigMaps souvent plus ouverts.

---
# Partie I- impl√©mentation simple de secret

##  **Labo 1 ‚Äì Secret utilis√© dans une commande (`command`)**

###  Objectif :

Cr√©er un `Secret` contenant un mot de passe, l‚Äôinjecter via une variable d‚Äôenvironnement, et l‚Äôutiliser dans une commande affich√©e dans les logs (‚ö†Ô∏è uniquement pour test).

---

###  Fichier Secret ‚Äì `secret-cmd.yaml`

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  DB_PASSWORD: c2VjcmV0MTIz  # Base64 de "secret123"
```

>  Pour encoder : `echo -n "secret123" | base64`

---

###  Fichier Pod ‚Äì `pod-secret-cmd.yaml`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-cmd
spec:
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "echo Le mot de passe est : $DB_PASSWORD && sleep 3600"]
    env:
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: DB_PASSWORD
```

---

###  Explication :

* Le Secret `mysecret` contient un mot de passe (`DB_PASSWORD`).
* Il est inject√© comme variable d‚Äôenvironnement dans le conteneur.
* Le conteneur ex√©cute une commande shell qui utilise cette variable (`$DB_PASSWORD`).

---

### üöÄ Commandes √† ex√©cuter :

```bash
kubectl apply -f secret-cmd.yaml
kubectl apply -f pod-secret-cmd.yaml
kubectl logs pod-secret-cmd
```
---

# Parie II - Montage d‚Äôun Secret comme fichier unique via subPath
Ppassons maintenant au **Labo 2 ‚Äì Montage d‚Äôun Secret comme fichier unique via `subPath`**.

###  Fichier Secret ‚Äì `secret-file.yaml`

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: apitoken
type: Opaque
data:
  token.txt: dG9rZW4tYWJjMTIz # Base64 de "token-abc123"
```

>  Encodage base64 : `echo -n "token-abc123" | base64`

---

###  Fichier Pod ‚Äì `pod-secret-file.yaml`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-file
spec:
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "cat /etc/secret/token.txt && sleep 3600"]
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secret/token.txt
      subPath: token.txt
  volumes:
  - name: secret-volume
    secret:
      secretName: apitoken
```

---

###  Explication :

* Le Secret contient un seul √©l√©ment (`token.txt`).
* Il est mont√© **comme un fichier unique** √† l‚Äôemplacement `/etc/secret/token.txt`.
* Le conteneur lit et affiche son contenu.

---

###  Commandes :

```bash
kubectl apply -f secret-file.yaml
kubectl apply -f pod-secret-file.yaml
kubectl logs pod-secret-file
```

---

# Partie III - Labo 3 ‚Äì Montage d‚Äôun Secret comme r√©pertoire (plusieurs fichiers).

###  Fichier Secret ‚Äì `secret-dir.yaml`

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: credentials
type: Opaque
data:
  username: YWRtaW4=         # "admin"
  password: cGFzc3dvcmQxMjM= # "password123"
```

>  Pour encoder :
> 
```bash
echo -n "admin" | base64      # YWRtaW4=
echo -n "password123" | base64 # cGFzc3dvcmQxMjM=
```

---

###  Fichier Pod ‚Äì `pod-secret-dir.yaml`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-dir
spec:
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "ls /etc/creds && cat /etc/creds/username && cat /etc/creds/password && sleep 3600"]
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/creds
      readOnly: true
  volumes:
  - name: secret-volume
    secret:
      secretName: credentials
```

---

###  Explication :

* Le Secret contient deux cl√©s : `username` et `password`.
* Chaque cl√© devient un fichier dans le dossier `/etc/creds`.
* Le conteneur affiche le contenu de ces deux fichiers.

---

###  Commandes :

```bash
kubectl apply -f secret-dir.yaml
kubectl apply -f pod-secret-dir.yaml
kubectl logs pod-secret-dir
```

---

# Partie IV  Parfait, terminons avec le **Labo 4 ‚Äì Injection d‚Äôun Secret dans des variables d‚Äôenvironnement**.

###  Fichier Secret ‚Äì `secret-env.yaml`

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  DB_USER: YWRtaW4=         # "admin"
  DB_PASS: cGFzc3dvcmQxMjM= # "password123"
```

>  Encodage base64 :

```bash
echo -n "admin" | base64       # YWRtaW4=
echo -n "password123" | base64 # cGFzc3dvcmQxMjM=
```

---

###  Fichier Pod ‚Äì `pod-secret-env.yaml`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-env
spec:
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "echo USER=$DB_USER && echo PASS=$DB_PASS && sleep 3600"]
    env:
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: DB_USER
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: DB_PASS
```

---

###  Explication :

* Le Secret contient 2 paires cl√©/valeur.
* Ces cl√©s sont inject√©es comme variables d‚Äôenvironnement nomm√©es `DB_USER` et `DB_PASS`.
* Le conteneur affiche les variables en clair (‚ö† √† ne pas faire en production, c‚Äôest juste pour d√©monstration).

---

###  Commandes :

```bash
kubectl apply -f secret-env.yaml
kubectl apply -f pod-secret-env.yaml
kubectl logs pod-secret-env
```



